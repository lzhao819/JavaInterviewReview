[TOC]

## 第8章 Java多线程与并发-原理

### synchronized

##### 线程不安全的原因

​	存在共享数据；存在多条线程共享这些共享数据；

##### 互斥锁特性

​	互斥性：同一时间只允许一个线程持有某个对象锁。也称操作的原子性。

​	可见性：必须确保释放锁之前对共享变量所做的修改对随后获得该锁的线程是可见的，否则会数据不一致。

​	锁的不是代码而是对象。

##### 根据获取的锁分类：对象锁 类锁

​	获取对象锁的两种方法：

	1. 同步代码块：synchronized(this), synchronized(类实例对象), 锁是括号中的实例对象
 	2. 同步非静态方法：synchronized method，锁是当前对象的实例对象

获取类锁的两种方法：

	1. 同步代码块 synchronized(类.class)，锁的是括号里的类对象
 	2. 同步静态方法 synchronized static method，锁是当前对象的类对象

##### 总结

1. 有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块
2. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步代码块的线程会被阻塞
3. 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞
4. 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步代码块的线程会被阻塞，反之亦然
5. 同一个类的不同对象的对象锁互不干扰
6. 类锁也是一种特殊的对象锁，因此表述和1234一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的
7. 类锁和对象锁互不干扰，因为是两个不同的对象锁

### synchronized的底层实现原理

##### 对象在内存中的布局：对象头，实例数据，对齐填充

##### 对象头的结构：Mark word(对象的Hashcode，分代年龄，锁类型，锁标识位) + Class Metadata Address(类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据)

##### Monitor: 每个java对象天生自带了一把看不见的锁，synchronized底层控制了monitor锁

​	同步代码块的底层是通过ObjectMonitor()实现, monitorenter, monitorexit

​	![image-20201104131952989](/Users/lu/Documents/project/JavaInterviewReview/docs/8.Java多线程与并发-原理.assets/image-20201104131952989.png)

同步方法的锁通过 ACC_SYNCHRONIZED标准来判断是否上锁，而没有monitorenter, monitorexit

##### synchronized缺点

​	早期依赖于mutex lock实现，重量级锁

​	线程之间的切换要从用户态转换到内核态，开销大

​	JDK6之后新增了很多锁来优化

### 自旋锁和自适应自旋锁 

##### 自旋锁

​	很多情况共享数据的锁定状态持续时间很短，切换线程不值得；

​	通过让线程执行忙循环等待锁的释放，不让出CPU；

​	缺点：若长时间被其他线程占用会带来很大消耗，可通过PreBlockSpin来控制自旋次数

##### 自适应自旋锁

​	自旋次数不再固定；

​	由前一次在同一个锁上的自旋时间及拥有者的状态来决定；





