##  第5章 Java底层知识：JVM

### 对java的理解

平台无关性/GC/语言特性：范型，反射，lamda/面向对象/类库/异常处理

### 平台无关性如何实现

.java文件 -- javac编译生成字节码 -- .class文件 -- JVM解析转化成特定平台的执行指令(JVM for Linux, JVM for Win,  JVM for IOS )

#### 为什么不直接将源码解析成机器码

准备工作：每次运行都需要检查，性能受损

兼容性：可以将别的语言解析成字节码

### JVM如何加载.class文件

<img src="public/5.Java底层知识JVM/image-20201118003318036.png" alt="image-20201118003318036" style="zoom:50%;" />

class loader:依据特定格式，加载class文件到内存

Execution engin:对命令解析

Native interface: 融合其他语言的方法为java所用

### 什么是反射(代码)

### 类从编译到执行的过程

* 编译器将.java 源文件编译成Robot.class字节码

* ClassLoader 将字节码转化为JVM的Class<Robot>对象（

* JVM将Class<Robot>对象实例化成Robot对象

#### ClassLoader

作用：ClassLoader主要在class装载的加载阶段，负责将class文件中的二进制数据流装载进系统，然后交给JVM进行连接、初始化等）

种类

* BootStrapClassLoader: C++编写，加载核心库java.*，用户无法修改
* ExtClassLoader: Java编写，加载扩展库javax.*,用户可见
* AppClassLoader: Java编写，加载程序所在目录
* 自定义ClassLoader: Java编写，定制化加载

#### ClassLoader双亲委派机制

APP —>EXC—>BOOT，自底向上检查是否已经加载，自顶向下加载类

加载过程

* 类加载器收到类加载的请求
* 将这个请求向上委托给父类加载器去完成，一层层向上委托，直到启动类加载器
* 启动加载器检查是否能够加载当前这个类，能加载就结束， 使用当前的加载器，否则， 抛出异常，通知子加载器进行加载
* 重复步骤3

为什么使用双亲委托？

* 为了保证安全，不让程序员故意制造bug
  * 从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;
  * 由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效

* 避免多份同样字节码的加载

### 类的加载方式

隐式加载：new

显示加载：loadClass, forName等

#### LoadClass和forName的区别

参考代码（LoadDifference）

* Class.forName得到的class是已经完成初始化的
* ClassLoader.loadClass得到的class是还没有链接的

##### 类的装载过程

* 加载：通过classloader将类加载文件字节码，生成class对象
* 链接
  * 校验：检查加载的class文件安全性和正确性
  * 准备：为类变量分配存储空间并设置类变量(static)初始值(默认值)
  * 解析：JVM将常量池中的符号引用转化为直接引用
* 初始化：执行变量赋值和静态代码块

### java内存模型

#### 内存简介













