## 第9章 Java框架-SpringFramework/SpringBoot/SpringCloud

### Spring Framework

#### 依赖注入（DI）与控制反转（IoC）

1. 核心原理：IoC是设计思想， DI是手段
* IoC(Inversion of Control)：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们创建对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。
* DI(Dependency Injection)：是IoC 的具体实现，容器通过构造器、字段或 setter 方法注入依赖。
    
   ```java
   //正转
   public class A
   {
       private B _b;
       public A()
       {
       // 因为A掌控B的创建，因此A控制了B，此为“正转”
       _b = new B();
       }
   }
   //反转
   public class A
   {
       private B _b;
    
       // B由外部注入，称之为依赖注入
       public A(B b)
       {
           // B由外部创建，脱离了A的控制，称之为控制反转
           _b = b;
       }
   }
   ```
2. 源码流程：容器启动时解析配置（如@Component），注册BeanDefinition；实例化 Bean 时通过反射创建对象，调用populateBean()完成属性注入。
3. 关键知识点
* 注入方式：构造器注入（线程安全）、字段注入（简洁但不可测试）、setter 注入（灵活）。
* 循环依赖：Spring 通过三级缓存（singletonObjects、earlySingletonObjects、singletonFactories）解决单例 Bean 的循环依赖，但 Prototype 作用域不支持。
* 自动装配：@Autowired按类型匹配，@Qualifier指定名称，@Resource按名称匹配（JDK 注解）。
4. 面试题：
* 为什么推荐构造器注入？（确保依赖不可变，避免 NPE）
* Spring 如何解决循环依赖？（早期暴露 Bean 引用）
* @Autowired和@Resource的区别？（依赖查找策略不同）

#### 面向切面编程（AOP）

1. 核心概念：
* 切面（Aspect）：横切逻辑的封装，如打印日志、事务、权限处理。（在代码相似的位置进行同样的处理）
* 通知（Advice）：切面的具体逻辑，通知有五种类型，分别是前置通知（@Before）、后置通知（@After）、返回通知（@AfterReturning）、异常通知（@AfterThrowing）和环绕通知（@Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。
* 切点（Pointcut）：定义通知作用的位置，通过正则表达式（如execution(* com.example.service.*.*(..))）匹配方法。

2. 实现原理：
* 动态代理：JDK 动态代理（基于接口）和 CGLIB（基于子类）。Spring 默认优先使用 JDK 代理，目标类无接口时用 CGLIB。
* 织入（Weaving）：在运行时将切面逻辑插入目标方法。
3. 应用场景：
* 事务管理（@Transactional）、日志记录、性能监控、权限控制。 
4. 面试题：
* AOP 的实现方式有哪些？如何选择？
* 解释@Around通知的执行流程。
* 如何自定义切面？（结合@Aspect和切点表达式）

#### 事务

Spring 并不直接管理事务，而是提供了多种事务管理器。Spring 事务管理器的接口是：PlatformTransactionManager 。

通过这个接口，Spring 为各个平台如：JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。

#### SpringMVC
* 异步请求：https://blog.csdn.net/zengfanwei1990/article/details/111026239

### Spring Boot

Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！

#### 自动配置原理：
* @EnableAutoConfiguration：通过AutoConfigurationImportSelector加载META-INF/spring.factories中的配置类，根据条件注解（如@ConditionalOnClass）动态启用配置。
* 条件注解：@ConditionalOnMissingBean（无自定义 Bean 时生效）、@ConditionalOnProperty（配置文件存在特定属性）。

#### Starter 作用：
* 一站式依赖管理，如spring-boot-starter-web自动引入 Tomcat、Spring MVC 等依赖。
* 自定义 Starter 需在spring.factories中声明自动配置类。

#### 企业级开发最佳实践
1. 配置管理：
   * 多环境配置：通过application-{profile}.properties或application.yml的spring.profiles块切换环境，优先级为：命令行参数 > 配置文件 > 系统属性。
   * 外部化配置：@Value注入单个属性，@ConfigurationProperties绑定复杂配置类。
2. 性能优化：
   * 缓存：@EnableCaching+@Cacheable，支持 Redis、Ehcache 等。
   * 异步处理：@Async配合线程池提升响应速度。
3. 监控与运维：
   * Actuator：暴露健康检查（/health）、指标（/metrics）等端点，可通过management.endpoints.web.exposure.include配置暴露范围。
   * 日志：使用 Slf4j+Logback，通过logging.level调整日志级别。

#### 企业级应用搭建
1. 分层架构：
   * Controller：处理请求，返回结果（@RestController）。
   * Service：封装业务逻辑，调用 DAO。
   * DAO：数据访问层（@Repository），使用 Spring Data JPA 或 MyBatis。
2. 事务管理：
   * @Transactional声明式事务，默认回滚运行时异常。
   * 事务传播行为（PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW）。
3. 异常处理：
   * @ControllerAdvice+@ExceptionHandler全局捕获异常，返回统一格式响应。

#### 面试题：
* Spring Boot 如何实现零配置？（自动配置 + Starter）
* 如何禁用某个自动配置？（@SpringBootApplication(exclude = ...)）
* 自定义 Starter 的步骤是什么？(spring.factories中声明自动配置类)
* Spring 与 Spring Boot 的区别：
  * Spring：需手动配置，灵活性高；Spring Boot：自动配置，开箱即用。
* Bean 的生命周期：
  * 实例化 → 依赖注入 → BeanPostProcessor前置处理 → 初始化（@PostConstruct） → BeanPostProcessor后置处理 → 销毁（@PreDestroy）。
* 循环依赖的处理：
  * 单例 Bean 通过三级缓存解决，Prototype Bean 需避免循环依赖。/Use @Lazy
* AOP 的底层实现：
  * JDK 动态代理生成接口代理类，CGLIB 生成目标类的子类。
* 如何实现多环境数据库配置？
* Actuator 的主要端点有哪些？如何保护敏感端点？
* 如何优化 Spring Boot 应用的启动速度？